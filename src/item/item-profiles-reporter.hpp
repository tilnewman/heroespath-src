// ----------------------------------------------------------------------------
// "THE BEER-WARE LICENSE" (Revision 42):
// <ztn@zurreal.com> wrote this file.  As long as you retain this notice you
// can do whatever you want with this stuff. If we meet some day, and you think
// this stuff is worth it, you can buy me a beer in return.  Ziesche Til Newman
// ----------------------------------------------------------------------------
#ifndef HEROESPATH_ITEM_ITEM_PROFILES_REPORTER_HPP_INCLUDED
#define HEROESPATH_ITEM_ITEM_PROFILES_REPORTER_HPP_INCLUDED
//
// item-profiles-reporter.hpp
//
#include "game/strong-types.hpp"
#include "item/item-profile.hpp"
#include "misc/real.hpp"
#include "misc/strings.hpp"
#include "misc/vector-map.hpp"
#include "misc/vectors.hpp"

#include <iomanip>
#include <numeric>
#include <string>
#include <vector>

namespace heroespath
{
namespace item
{

    // Responsible for logging details about the kinds of items generated by ItemProfileWarehouse.
    struct ItemProfilesReporter
    {
        static void LogReport();

    private:
        static std::string toNumberSpecialForType(const double NUMBER, const int WIDTH);
        static std::string toNumberSpecialForType(const long long NUMBER, const int WIDTH);

        template <typename T>
        static std::enable_if_t<misc::are_floating_point_v<T>, const std::string>
            toNumberSpecial(const T NUMBER, const int WIDTH)
        {
            return toNumberSpecialForType(static_cast<double>(NUMBER), WIDTH);
        }

        template <typename T>
        static std::enable_if_t<!misc::are_floating_point_v<T>, const std::string>
            toNumberSpecial(const T NUMBER, const int WIDTH)
        {
            return toNumberSpecialForType(static_cast<long long>(NUMBER), WIDTH);
        }

        template <typename T>
        struct MinMaxAvgStdDev
        {
            MinMaxAvgStdDev(const std::vector<T> & VALUES, const std::size_t COUNT)
                : count(0)
                , min(0)
                , max(0)
                , avg(0)
                , sum(0)
                , stddev(0)
            {
                Setup(VALUES, COUNT);
            }

            explicit MinMaxAvgStdDev(const std::vector<T> & VALUES)
                : count(0)
                , min(0)
                , max(0)
                , avg(0)
                , sum(0)
                , stddev(0)
            {
                Setup(VALUES, VALUES.size());
            }

            MinMaxAvgStdDev(const MinMaxAvgStdDev &) = default;
            MinMaxAvgStdDev(MinMaxAvgStdDev &&) = default;
            MinMaxAvgStdDev & operator=(const MinMaxAvgStdDev &) = default;
            MinMaxAvgStdDev & operator=(MinMaxAvgStdDev &&) = default;

            void Reset()
            {
                count = 0;
                min = T(0);
                max = T(0);
                avg = T(0);
                sum = T(0);
                stddev = T(0);
            }

            void Setup(const std::vector<T> & VALUES) { Setup(VALUES, VALUES.size()); }

            void Setup(const std::vector<T> & VALUES, const std::size_t COUNT)
            {
                Reset();

                if ((VALUES.size() < 3) || (COUNT < 3) || ((COUNT - 1) > VALUES.size()))
                {
                    return;
                }

                count = COUNT;
                min = VALUES.front();
                max = min;

                using Math_t = long double;

                Math_t tempSum { 0.0L };

                for (std::size_t index { 0 }; index < COUNT; ++index)
                {
                    const auto VALUE { VALUES.at(index) };

                    if (VALUE < min)
                    {
                        min = VALUE;
                    }

                    if (VALUE > max)
                    {
                        max = VALUE;
                    }

                    tempSum += static_cast<Math_t>(VALUE);
                }

                avg = static_cast<T>(tempSum / static_cast<Math_t>(COUNT));
                sum = static_cast<T>(tempSum);

                stddev = misc::Vector::StandardDeviation(VALUES, COUNT, avg);
            }

            const std::string ToString(
                const bool WILL_INCLUDE_COUNT = false,
                const bool WILL_INCLUDE_SUM = false,
                const std::size_t WIDTH = 0) const
            {
                std::string str;
                str.reserve(255);
                const auto WIDTH_INT { static_cast<int>(WIDTH) };

                if (WILL_INCLUDE_COUNT)
                {
                    str += "x" + toNumberSpecial(count, WIDTH_INT) + " ";
                }

                str += "[" + toNumberSpecial(min, WIDTH_INT) + ", "
                    + toNumberSpecial(avg, WIDTH_INT) + ", " + toNumberSpecial(max, WIDTH_INT)
                    + "] (" + toNumberSpecial(stddev, WIDTH_INT) + ")";

                if (WILL_INCLUDE_SUM)
                {
                    str += " (sum=" + std::to_string(sum) + ")";
                }

                return str;
            }

            std::size_t count;
            T min;
            T max;
            T avg;
            T sum;
            T stddev;
        };

        struct SourceProfiles
        {
            SourceProfiles(
                const std::size_t SOURCE_PROFILES_COUNT,
                const std::size_t SOURCE_RELIGIOUS_PROFILES_COUNT,
                const std::size_t SOURCE_PROFILES_SCORE_SUM,
                const std::size_t SOURCE_RELIGIOUS_PROFILES_SCORE_SUM)
                : normal_count(SOURCE_PROFILES_COUNT)
                , religious_count(SOURCE_RELIGIOUS_PROFILES_COUNT)
                , normal_score_sum(SOURCE_PROFILES_SCORE_SUM)
                , religious_score_sum(SOURCE_RELIGIOUS_PROFILES_SCORE_SUM)
            {}

            std::size_t normal_count;
            std::size_t religious_count;
            std::size_t normal_score_sum;
            std::size_t religious_score_sum;
        };

        // Responsible for holding a specific set of profiles and for generating a report on them.
        class Report
        {
        public:
            explicit Report(const std::string & DESCRIPTION = "")
                : description_(DESCRIPTION)
                , scores_()
                , religiousScores_()
                , miscCount_(0)
                , elementalCount(0)
                , scoresSet_()
                , scoresNamed_()
                , scoresUnique_()
                , scoresPixie_()
                , elementScoreMap_()
            {}

            virtual ~Report() = default;

            void SetDescription(const std::string & DESCRIPTION) { description_ = DESCRIPTION; }

            virtual bool Add(const ItemProfile & PROFILE, const bool WILL_ADD);

            std::size_t Count() const { return scores_.size(); }

            const std::string ToString(const SourceProfiles &);

            virtual const std::string
                Make(const SourceProfiles &, const bool WILL_LIMIT_TO_ONE_LINE = false) const;

            const std::string ReportCountPhrase(const std::size_t COUNT_COMPARED_WITH) const;

        protected:
            std::string description_;
            std::vector<std::size_t> scores_;
            std::vector<std::size_t> religiousScores_;
            std::size_t miscCount_ { 0 };
            std::size_t elementalCount { 0 };
            mutable std::vector<std::size_t> scoresSet_;
            mutable std::vector<std::size_t> scoresNamed_;
            mutable std::vector<std::size_t> scoresUnique_;
            mutable std::vector<std::size_t> scoresPixie_;
            mutable misc::VectorMap<element_type::Enum, std::vector<std::size_t>> elementScoreMap_;
        };

        struct SpecificItemInfo
        {
            std::vector<std::size_t> scores;
            MaterialPairVec_t material_pairs;
        };

        class WeaponOrArmorReport : public Report
        {
        public:
            explicit WeaponOrArmorReport(
                const bool IS_WEAPON_REPORT, const std::string & DESCRIPTION_POSTFIX = "")
                : Report(((IS_WEAPON_REPORT) ? "weapons" : "armor") + DESCRIPTION_POSTFIX)
            {
                isWeaponReport_ = IS_WEAPON_REPORT;
            }

            bool Add(const ItemProfile & PROFILE, const bool WILL_ADD) override;

            const std::string
                Make(const SourceProfiles &, const bool WILL_LIMIT_TO_ONE_LINE) const override;

        protected:
            bool isWeaponReport_;
            mutable misc::VectorMap<std::string, Report> reportMap_;
            mutable misc::VectorMap<std::string, SpecificItemInfo> specificMap_;
        };

        class StandardSetReport : public Report
        {
        public:
            explicit StandardSetReport(const std::string & DESCRIPTION)
                : Report(DESCRIPTION)
            {}

            bool Add(const ItemProfile & PROFILE, const bool WILL_ADD) override;

            const std::string
                Make(const SourceProfiles &, const bool WILL_LIMIT_TO_ONE_LINE) const override;

        protected:
            mutable misc::VectorMap<std::string, Report> reportMap_;
        };

        template <typename T, typename U>
        static double DivideAsDouble(const T NUMERATOR, const U DENOMINATOR_ORIG)
        {
            const auto DENOMINATOR = static_cast<double>(DENOMINATOR_ORIG);

            if (!misc::IsRealZeroOrLess(DENOMINATOR))
            {
                return (static_cast<double>(NUMERATOR) / DENOMINATOR);
            }
            else
            {
                return -0.0;
            }
        }

        static const std::string RatioToStringStringMaker(
            const int DIGITS,
            const std::string & POSTFIX,
            const double AFTER_DIVISION,
            const bool WILL_WRAP);

        template <typename T, typename U>
        static const std::string RatioToString(
            const T NUMERATOR,
            const U DENOMINATOR,
            const bool WILL_WRAP = false,
            const std::string & POSTFIX = "",
            const int DIGITS = 4)
        {
            if (DENOMINATOR > 0)
            {
                return RatioToStringStringMaker(
                    DIGITS, POSTFIX, DivideAsDouble(NUMERATOR, DENOMINATOR), WILL_WRAP);
            }
            else
            {
                return "(divide_by_zero_error)";
            }
        }

        template <typename T, typename U>
        static const std::string
            PercentToString(const T NUMERATOR, const U DENOMINATOR, const bool WILL_WRAP = true)
        {
            if (DENOMINATOR > 0)
            {
                return RatioToString(NUMERATOR, DENOMINATOR, WILL_WRAP, "%", 3);
            }
            else
            {
                return "100%";
            }
        }

        // NAME_count=#(#%)
        template <typename T, typename U>
        static const std::string
            CountPhrase(const std::string & NAME, const T COUNT, const U COUNT_COMPARED_WITH)
        {
            std::string str;
            str.reserve(64);

            str += (", " + NAME + "_count=" + std::to_string(COUNT));

            if (COUNT_COMPARED_WITH > 0)
            {
                str += PercentToString(COUNT, COUNT_COMPARED_WITH);
            }

            return str;
        }

        static const std::string
            SumPhraseStringMaker(const std::string & NAME, const std::string & STATS_STR);

        // NAME=[min, avg, max](#sum)(#std_dev)(#%)
        template <typename T, typename U>
        static const std::string SumPhrase(
            const std::string & NAME, const std::vector<T> & VALUES, const U SUM_COMPARED_WITH = 0)
        {
            const auto STATS { MinMaxAvgStdDev<T>(VALUES) };

            std::string str(SumPhraseStringMaker(NAME, STATS.ToString(false, true, 4)));

            if (SUM_COMPARED_WITH > 0)
            {
                str += PercentToString(STATS.sum, SUM_COMPARED_WITH);
            }

            return str;
        }
    };

} // namespace item
} // namespace heroespath

#endif // HEROESPATH_ITEM_ITEM_PROFILES_REPORTER_HPP_INCLUDED
